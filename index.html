<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>ウパ迷路オンライン</title>
<style>
body{margin:0;background:#111;color:#fff;font-family:sans-serif;touch-action:none;overflow:hidden;}
canvas{display:block;margin:0 auto;background:#000;touch-action:none}
#timer{position:absolute;top:10px;left:50%;transform:translateX(-50%);font-size:32px;font-weight:bold;color:#fff;background:rgba(0,0,0,0.7);border-radius:6px;padding:4px 12px;z-index:2;text-align:center;}
#timeDisplay{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:48px;font-weight:bold;color:#fff;background:rgba(0,0,0,0.7);padding:10px 20px;border-radius:10px;display:none;z-index:3;text-align:center;}
#totalTime{position:absolute;top:20%;left:50%;transform:translateX(-50%);font-size:28px;font-weight:bold;color:#ff0;z-index:12;text-align:center;display:none;text-shadow:0 0 6px #000;}
#ui{position:fixed;bottom:0;left:0;width:100%;padding:8px;background:rgba(20,20,20,0.9);display:flex;flex-direction:column;gap:8px;z-index:2;box-sizing:border-box;}
#ctrl{display:grid;grid-template-columns:70px 70px 70px;gap:6px;justify-content:center}
button{font-size:18px;border:none;border-radius:10px;padding:10px;touch-action:none;color:#fff;background:#444}
#bottom{display:flex;justify-content:center;align-items:center;gap:12px;flex-wrap:wrap}
#compass{width:60px;height:60px;border:2px solid #fff;border-radius:50%;position:relative}
#needle{position:absolute;left:50%;top:50%;width:4px;height:26px;background:red;transform-origin:bottom center}
#specialOverlay{position:fixed;top:0;left:0;width:100%;height:100%;background:#000c;display:flex;justify-content:center;align-items:center;flex-direction:column;z-index:10;display:none}
#specialOverlay img{max-width:90%;max-height:70%}
#specialOverlay button{margin-top:20px;padding:12px 24px;font-size:20px;border-radius:10px}
#muteBtn{font-size:16px;padding:6px 12px;border-radius:6px;background:#666}
#count{font-size:18px;}
</style>
</head>
<body>
<canvas id="cv"></canvas>
<div id="timer">00:00</div>
<div id="timeDisplay"></div>
<div id="ui">
  <div id="ctrl">
    <div></div><button id="up">↑</button><div></div>
    <button id="left">←</button><button id="down">↓</button><button id="right">→</button>
  </div>
  <div id="bottom">
    <div id="compass"><div id="needle"></div></div>
    <button id="regen">スタート</button>
    <button id="muteBtn">おと: ON</button>
    <div id="count">ゴール: 0 / かんたん</div>
  </div>
</div>

<div id="specialOverlay">
  <img id="specialImg" src="">
  <div id="totalTime"></div>
  <button id="nextBtn">つぎへ</button>
</div>

<script>
const cv=document.getElementById('cv');
const ctx=cv.getContext('2d');
const goalSE=new Audio('goal.mp3');
let isMuted=false;

let goalCount=0, px=0, py=0, goal={x:0,y:0};
let W=21,H=21;
const TILE=32;
const difficulties=['かんたん','ふつう','むずかしい'];
let currentDifficulty=0;
let firstHardCleared=false;
let totalSeconds=0; // 通算タイム（秒）
let playerImg=new Image();
playerImg.src='player.png';

const specialOverlay=document.getElementById('specialOverlay');
const specialImg=document.getElementById('specialImg');
const timeDisplay=document.getElementById('timeDisplay');
const timerEl=document.getElementById('timer');
const totalTimeEl=document.getElementById('totalTime');

let maze=[];
let timerInterval=null;
let startTime=0;

function getSizeByDifficulty(index){
    if(index===0) return 11;
    if(index===1) return 21;
    if(index===2) return 31;
    if(index===3) return 201; // げきむず
    return 21;
}

function resizeCanvas(){
    cv.width=Math.min(innerWidth,W*TILE);
    cv.height=Math.min(innerHeight-200,H*TILE);
}
addEventListener('resize',resizeCanvas);

function genMaze(){
    maze=Array.from({length:H},()=>Array(W).fill(1));
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
    function dfs(x,y){
        maze[y][x]=0;
        let dirs=shuffle([[2,0],[-2,0],[0,2],[0,-2]]);
        for(const [dx,dy] of dirs){
            const nx=x+dx, ny=y+dy;
            if(nx>0&&nx<W-1&&ny>0&&ny<H-1 && maze[ny][nx]===1){
                maze[y+dy/2][x+dx/2]=0;
                dfs(nx,ny);
            }
        }
    }
    dfs(1,1);
    let extraPaths=Math.floor(W*H*0.03);
    for(let i=0;i<extraPaths;i++){
        let x=Math.floor(Math.random()*(W-2))+1;
        let y=Math.floor(Math.random()*(H-2))+1;
        if(maze[y][x]===1){
            let neighbors=0;
            if(maze[y+1][x]===0) neighbors++;
            if(maze[y-1][x]===0) neighbors++;
            if(maze[y][x+1]===0) neighbors++;
            if(maze[y][x-1]===0) neighbors++;
            if(neighbors===1) maze[y][x]=0;
        }
    }
    px=1; py=1;
}

function setGoal(){ goal={x:W-2,y:H-2}; }

function reset(){
    W=H=getSizeByDifficulty(currentDifficulty);
    resizeCanvas();
    genMaze();
    setGoal();
    draw();
    updateCount();
    totalTimeEl.style.display='none';
}

function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    const ox=px-Math.floor(cv.width/(2*TILE));
    const oy=py-Math.floor(cv.height/(2*TILE));
    for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
            const sx=(x-ox)*TILE, sy=(y-oy)*TILE;
            if(sx<-TILE||sy<-TILE||sx>cv.width||sy>cv.height) continue;
            ctx.fillStyle=maze[y][x]? '#333':'#ddd';
            ctx.fillRect(sx,sy,TILE,TILE);
        }
    }
    ctx.fillStyle='gold';
    ctx.fillRect((goal.x-ox)*TILE,(goal.y-oy)*TILE,TILE,TILE);
    ctx.drawImage(playerImg,cv.width/2-TILE/3,cv.height/2-TILE/3,TILE*2/3,TILE*2/3);
    updateCompass();
}

function updateCompass(){
    const dx=goal.x-px;
    const dy=goal.y-py;
    const ang=Math.atan2(dy,dx)+Math.PI/2;
    document.getElementById('needle').style.transform=`translate(-50%,-100%) rotate(${ang}rad)`;
}

function updateCount(){
    document.getElementById('count').textContent=`ゴール: ${goalCount} / ${difficulties[currentDifficulty]||'げきむず'}`;
}

// タイマー
function startTimer(){
    startTime=Date.now();
    clearInterval(timerInterval);
    timerInterval=setInterval(()=>{
        const elapsed=Math.floor((Date.now()-startTime)/1000);
        const min=String(Math.floor(elapsed/60)).padStart(2,'0');
        const sec=String(elapsed%60).padStart(2,'0');
        timerEl.textContent=`${min}:${sec}`;
    },1000);
}

function stopTimer(){
    clearInterval(timerInterval);
}

function formatTime(seconds){
    const min=Math.floor(seconds/60);
    const sec=seconds%60;
    return `${min}分${sec}秒`;
}

// 移動
let moveTimer=null;
function startMove(dx,dy){if(moveTimer)return; move(dx,dy); moveTimer=setInterval(()=>move(dx,dy),180);}
function stopMove(){clearInterval(moveTimer); moveTimer=null;}

function move(dx,dy){
    const nx=px+dx, ny=py+dy;
    if(maze[ny] && maze[ny][nx]===0){
        px=nx; py=ny;
        draw();
        if(px===goal.x && py===goal.y){
            stopTimer();
            const elapsedSec=Math.floor((Date.now()-startTime)/1000);
            totalSeconds+=elapsedSec;
            timeDisplay.style.display='block';
            timeDisplay.textContent=formatTime(elapsedSec);

            if(!isMuted) goalSE.currentTime=0, goalSE.play();

            goalCount++;
            if(goalCount===3 || goalCount===11){
                totalTimeEl.style.display='block';
                totalTimeEl.textContent=`通算タイム: ${formatTime(totalSeconds)}`;
            }

            if(goalCount===3 || goalCount===10 || goalCount===11){
                if(goalCount===3) specialImg.src='special_hard.png';
                if(goalCount===10) specialImg.src='special_10.png';
                if(goalCount===11) specialImg.src='special_11.png';
                specialOverlay.style.display='flex';
            } else {
                setTimeout(nextMaze,800);
            }
        }
    }
}

function nextMaze(){
    timeDisplay.style.display='none';
    totalTimeEl.style.display='none';
    if(goalCount===10) currentDifficulty=3;
    else currentDifficulty=(currentDifficulty+1)%difficulties.length;
    reset();
    startTimer();
}

document.getElementById('nextBtn').onclick=function(){
    specialOverlay.style.display='none';
    nextMaze();
};

document.getElementById('muteBtn').onclick=function(){
    isMuted=!isMuted;
    this.textContent='おと: '+(isMuted?'OFF':'ON');
};

document.getElementById('regen').onclick=function(){
    totalSeconds=0;
    totalTimeEl.style.display='none';
    reset();
    startTimer();
};

const btns={up:[0,-1],down:[0,1],left:[-1,0],right:[1,0]};
Object.keys(btns).forEach(id=>{
    const b=document.getElementById(id);
    const [dx,dy]=btns[id];
    b.ontouchstart=e=>{e.preventDefault();startMove(dx,dy)};
    b.ontouchend=stopMove;
    b.onmousedown=()=>startMove(dx,dy);
    b.onmouseup=stopMove;
    b.onmouseleave=stopMove;
});

window.addEventListener('keydown',e=>{
    if(e.repeat) return;
    if(e.key==='ArrowUp') startMove(0,-1);
    if(e.key==='ArrowDown') startMove(0,1);
    if(e.key==='ArrowLeft') startMove(-1,0);
    if(e.key==='ArrowRight') startMove(1,0);
});
window.addEventListener('keyup',stopMove);

let touchStartX=0, touchStartY=0, lastDir=null, inertiaTimer=null;
cv.addEventListener('touchstart', e=>{
    const t=e.touches[0];
    touchStartX=t.clientX; touchStartY=t.clientY;
    if(inertiaTimer){ clearInterval(inertiaTimer); inertiaTimer=null; }
});
cv.addEventListener('touchmove', e=>{
    e.preventDefault();
    const t=e.touches[0];
    const dx=t.clientX-touchStartX;
    const dy=t.clientY-touchStartY;
    let moved=false;
    if(Math.abs(dx)>Math.abs(dy)){
        if(dx>30){ move(1,0); lastDir=[1,0]; touchStartX=t.clientX; moved=true; }
        else if(dx<-30){ move(-1,0); lastDir=[-1,0]; touchStartX=t.clientX; moved=true; }
    } else {
        if(dy>30){ move(0,1); lastDir=[0,1]; touchStartY=t.clientY; moved=true; }
        else if(dy<-30){ move(0,-1); lastDir=[0,-1]; touchStartY=t.clientY; moved=true; }
    }
    if(moved && inertiaTimer) clearInterval(inertiaTimer);
});
cv.addEventListener('touchend', e=>{
    if(lastDir){
        inertiaTimer=setInterval(()=>move(lastDir[0],lastDir[1]),150);
        setTimeout(()=>{ clearInterval(inertiaTimer); inertiaTimer=null; lastDir=null; },500);
    }
});

reset();
</script>
</body>
</html>
